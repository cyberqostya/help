***
## <a name="a1"></a> Event Loop
Цикл событий (event loop) - это механизм, используемый в JavaScript для обработки событий и выполнения асинхронного кода.  
Он позволяет программе эффективно обрабатывать события, такие как пользовательские действия, таймеры, сетевые запросы и другие асинхронные операции.
1. **Ожидание возникновения событий.**
2. **Обработка событий.**  
   Происходит -> помещается в очередь событий (event queue) -> Цикл событий извлекает событие из очереди и передает его на обработку.
4. **Выполнение обработчиков событий.**  
   Цикл событий вызывает соответствующий обработчик события. Обработчик выполняется синхронно, то есть блокирует выполнение других событий до завершения.
6. **Обработка асинхронного кода.**  
   Если в обработчике события есть асинхронный код, такой как таймеры или сетевые запросы, он не блокирует выполнение других событий. Вместо этого асинхронный код помещается в очередь задач (task queue) для выполнения в будущем.
8. **Возврат к ожиданию событий.**  
   После выполнения всех обработчиков событий и обработки асинхронного кода, цикл событий возвращается к ожиданию новых событий. Процесс повторяется, пока не будет завершена работа программы.
   
...

1. Сначала Event Loop проверяет выполнились ли все синхронные задачи
2. Потом выполняются все задачи из микротасков (then у промисов, а также Intersection Observer - позволяет веб-приложениям асинхронно следить за изменением пересечения элемента с его родителем или областью видимости документа viewport.)
1. После выполнения всех микротасков - очередь очищается (.then(2).then(3) И .then(4).then(5) -> 2435)
1. Затем мы берем одну макрозадачу из списка и выполняем ее (XmlHTTPRequest, setTimeout и так далее)
1. После выполнения мы смотрим нужно ли нам сделать перерисовку страницы
1. Если перерисовать страницу нужно - делаем это
1. Все снова начинается с первого пункта :)
***


***
## <a name="a2"></a> Типы данных
1. Number (число)
1. String (строка)
1. Boolean (логический)
1. BigInt (1234567890123456789n * 123n) (точность, финансы) | Number.MAX_SAFE_INTEGER + 1;
1. Symbol используется для создания уникальных идентификаторов в объектах
1. null значение, которое представляет собой «ничего», «пусто» или «значение неизвестно» typeof null = object
1. undefiend означает, что «значение не было присвоено»
1. Object function - особенный вывод
***


***
## <a name="a3"></a> This
this - это специальное ключевое слово в JavaScript, которое ссылается на объект, в контексте которого выполняется текущий код.
1. Мы находимся внутри функции?  
Да: смотрим следующий пункт.  
Нет: this равен глобальному объекту.
1. Мы находимся внутри стрелочной функции?  
Да: значение this такое же, как и в функции на уровень выше (т.е. содержащей данную). Вернитесь на предыдущий шаг и повторите алгоритм для неё. Если же функция не содержится ни в какой другой, this — глобальный объект.  
Нет: смотрим следующий пункт.  
1. Эта функция вызвана как конструктор (с помощью оператора new)?  
Да: this ссылается на новый объект, находящийся «в процессе конструкции».  
Нет: смотрим следующий пункт.
1. Эта функция создана с помощью метода bind?  
Да: значение this равняется значению первого аргумента, который мы передали в метод bind при создании данной функции.  
Нет: смотрим следующий пункт.
1. Эта функция передана куда-то в качестве колбэка или обработчика?  
Да: одному Господу известно, чему будет равен this при её вызове. Идите читать документацию по той штуке, которая её станет вызывать.  
Нет: смотрим следующий пункт.
1. Эта функция вызвана с помощью метода apply или call?  
Да: в таком случае this равняется первому аргументу, переданному соответствующему методу.  
Нет: смотрим следующий пункт.
1. Эта функция получена как значение свойства объекта и сразу же вызвана?  
Да: this равняется вышеупомянутому объекту.  
Нет: смотрим следующий пункт.
1. Код выполняется в строгом режиме? ('use strict', ES6 модуль)  
Да: this равняется undefined.  
Нет: this равен глобальному объекту.
***


***
## <a name="a4"></a> Promise
Promise - это объект в JavaScript, который представляет результат асинхронной операции. Промис позволяет обрабатывать результат операции, когда он станет доступным, вместо того, чтобы блокировать выполнение кода и ожидать завершения операции.
Промис может находиться в одном из трех состояний:  
1. Pending: Исходное состояние промиса. Он находится в ожидании выполнения или отклонения операции.
1. Fulfilled: Промис переходит в это состояние, когда операция успешно завершается. В этом случае промис возвращает результат операции.
1. Rejected: Промис переходит в это состояние, когда операция завершается с ошибкой. В этом случае промис возвращает причину ошибки.
***


***
## <a name="a5"></a> Сборщик мусора
Сборщик мусора в JavaScript является встроенной функцией, которая автоматически освобождает память, занятую объектами, которые больше не используются в программе. Он следит за объектами, которые были созданы во время выполнения программы, и определяет, когда они больше не доступны для использования.
***


***
## <a name="a6"></a> Из чего состоит HTTP запрос
1. Метод запроса (Request Method): Определяет тип операции, которую клиент хочет выполнить на сервере GET, POST, PUT, DELETE и HEAD.
1. Заголовки (Headers): Представляют собой метаданные, дополнительную информацию о запросе, такую как тип содержимого, аутентификация, кеширование и другие параметры.
1. Тело запроса (Request Body): Используется только в некоторых методах запроса, таких как POST или PUT. Оно содержит данные, которые клиент отправляет на сервер, например, форму для отправки или JSON-объект.
***


***
## <a name="a7"></a> Map, Set
Map – коллекция для хранения записей вида ключ:значение, ключом может быть произвольное значение
```
map.set('1', 'str1');   // ключ-строка
map.set(1, 'num1');
```
Set – коллекция для хранения множества уникальныъ значений.
***


***
## <a name="a8"></a> О большое | Временная сложность
O большое - это способ описать эффективность алгоритмов. Он описывает, как время, затрачиваемое на выполнение, растет по мере увеличения размера входных данных.  
Временная сложность - это способ показать, как время выполнения функции увеличивается с ростом размера входных данных.  
1. Постоянное время, O(1) - Если мы выполняем действия, требующие только одного шага, или когда нет циклов.
1. Линейное время, O(n) - циклы, такие как циклы for и while, то есть то, что вызывает увеличение времени выполнения на величину, пропорциональную размеру входа.
1. Квадратичное время, O(n²) - Два вложенных цикла с одинаковым входом. Аналогично, если у нас три вложенных цикла, то временная сложность - кубическое время, O(n³). Пузырьковая сортировка, сортировка вставкой
1. Логарифмическое время, O(log n) - Когда используется стратегия "разделяй и властвуй". Логарифмическое время часто встречается в бинарном поиске, это хороший показатель.
1. Факториальное время, O(n!) - Он самый сложный. Мы добавляем вложенный цикл для каждого элемента, пожалейте ваш компьютер.
...  
Правила определения О большого
1. Наихудший случай - когда есть и константа O(1) и цикл O(n) считаем что эффективность = O(n)
2. Удалить константы - когда имеем O(3n+2) то в итоге O(n)
3. Различные термины для входов - когда имеем циклы по разным данным получаем O(n+m)
4. Отбросить недоминирующие значения - когда O(n^2 + n) получим O(n)
***


***
```
string.endsWith();
string.lastIndexOf();
number.toString(16)
```
***
